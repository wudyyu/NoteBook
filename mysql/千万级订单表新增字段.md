> 1.故事背景

>> 最近我们遇到了一个看似简单但背后很有坑的需求：在千万级订单表中新增一个业务字段。需求来自隔壁项目组，他们需要这个字段做一些统计分析
>> 从开发角度看，这事很常见，新增字段嘛，直接ALTER TABLE加一下不就行了？ 但问题是——订单表是线上核心表，千万级数据，直接执行DDL语句极有可能锁表，影响线上业务运行，后果严重

>> 于是问题就来了：在不影响线上业务的前提下，怎么给千万级订单表加字段？


> 2.案例

>> 2.1  DDL操作会锁表，线上执行慎之又慎
>> 我们最初考虑的方案是直接在主库执行：
```
ALTER TABLE order ADD COLUMN new_field VARCHAR(255);
```
>> 理论上只是一条SQL，但我们知道在MySQL（尤其是老版本）中执行DDL是会锁表的。哪怕是短时间，也可能引发业务请求阻塞，造成雪崩


>> 2.2  主从切换方案：从库加字段，再主从切换

> > >> 主库继续执行业务；

>>>> 从库上执行ALTER TABLE新增字段；

>>>> 执行完之后，把从库提升为主库；

>>>> 再对原主库做一样的操作，恢复原来的主从关系

>> 2.3 在线DDL方案：背后其实很复杂
>> 在线DDL其实是借助“创建一个新表 + 复制数据 + 写触发器 + 表名切换”来实现的

>> 2.4 扩展表，按需关联查询

```
order_extend
- order_id
- extra_field_x
- extra_field_y

```

>> 原表不动，有新字段时写到扩展表里，业务查询时做JOIN

>> 虽然查询麻烦点，但优点是:

> > >> 主表结构稳定

>>>> 扩展字段可动态管理

>>>> 不影响现有业务逻辑

>> 2.5 高级玩法：JSON扩展字段
>> 不如你们统一定义一个ext字段，类型为TEXT或JSON，所有新增字段都塞到里面去，用规则解析即可

>> 比如

```
{
  "source": "marketing",
  "utm_campaign": "202406-promo",
  "coupon": "ABCD1234"
}
```

>> 这样一来，以后有新字段就塞进去，不用再修改表结构，非常灵活
>> 这种设计也叫做 “schema-less”扩展结构 ，在很多互联网公司是标准做法

>> 2.6 最终解决方案：利用冗余字段，回收再利用
>> 我们在查表结构的时候发现，订单表里有一个历史字段叫 remark_ext，一直没人用，占了512长度

>> 我灵光一闪：干脆把我们的扩展信息塞到这个冗余字段里

>> 于是我们约定了格式，做了封装写入，完美解决问题，而且

>> 1.不用加字段；

>> 2.不用关联查询

>> 3.不用上线新表

>> 当然产品也提了个关键问题： “这个字段长度够吗？后面扩展多了怎么办？”

>> 我查了下现在是512，考虑到未来需求，打算调到2000

>> 然后我在测试环境搞了个1亿条记录的表，执行

```
ALTER TABLE order MODIFY COLUMN remark_ext VARCHAR(2000);
```

>> 结果发现：

>> 调大字段长度不会锁表 ；

>> 调小字段长度会锁表 （因为要判断是否超长）









































































