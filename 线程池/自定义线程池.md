1. 核心设计思路
资源隔离：风控计算（CPU密集型）与风控入库/三方查询（IO密集型）分开。
链路传递：内置 TransmittableThreadLocal 支持，确保 TID 自动从 HTTP 线程传到风控子线程。
动态监控：提供方法实时打印线程池状态（核心数、活跃数、队列积压数）。
优雅关闭：集成 Java 11 的进程关闭钩子，防止任务丢失。
2. 依赖引入 (Maven)
```
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>transmittable-thread-local</artifactId>
    <version>2.14.2</version>
</dependency>

<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.25</version>
```

3. 编写风控专用线程池工具类
我们通过 @Configuration 将线程池交给 Spring 管理，这样可以利用 Spring 的 @PreDestroy 在应用关闭时优雅地停机

```
import com.alibaba.ttl.TransmittableThreadLocal;
import com.alibaba.ttl.threadpool.TtlExecutors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 2026 金融风控专用线程池配置 (Java 11 + Spring Boot 2.3.12)
 * 特点：链路追踪透传、资源隔离、优雅关闭
 */
@Configuration
public class RiskThreadPoolConfig {

    private static final Logger log = LoggerFactory.getLogger(RiskThreadPoolConfig.class);

    // 1. 全局 TraceID 容器
    public static final TransmittableThreadLocal<String> TRACE_ID_HOLDER = new TransmittableThreadLocal<>();

    @Bean(name = "riskExecutor")
    public ExecutorService riskExecutor() {
        int cpuCores = Runtime.getRuntime().availableProcessors();
        
        // 2. 金融风控参数建议：
        // 核心线程：CPU核数+1，保证高负载下的稳定吞吐
        // 最大线程：CPU核数*2，应对突发流量
        // 队列：有界队列 500，防止 OOM
        // 拒绝策略：CallerRunsPolicy，由调用方执行，实现天然限流，保证风控任务不丢失
        ThreadPoolExecutor rawExecutor = new ThreadPoolExecutor(
                cpuCores + 1,
                cpuCores * 2,
                60L, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(500),
                new RiskThreadFactory("risk-engine"),
                new ThreadPoolExecutor.CallerRunsPolicy() 
        );

        // 允许核心线程在闲置时超时销毁，进一步节省系统资源
        rawExecutor.allowCoreThreadTimeOut(true);

        // 3. 关键：使用 TTL 包装，实现父子线程上下文（TID）自动拷贝
        return TtlExecutors.getTtlExecutorService(rawExecutor);
    }

    /**
     * 自定义线程工厂，实现原生 Java 线程命名
     */
    static class RiskThreadFactory implements ThreadFactory {
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

        RiskThreadFactory(String prefix) {
            this.namePrefix = prefix + "-pool-thread-";
        }

        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
            if (t.isDaemon()) t.setDaemon(false);
            if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY);
            return t;
        }
    }
}

```



```
import cn.hutool.core.thread.ThreadFactoryBuilder;
import com.alibaba.ttl.TransmittableThreadLocal;
import com.alibaba.ttl.threadpool.TtlExecutors;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;

/**
 * 风控专用线程池工具类 (2026 规范版)
 * 场景：高并发风险核查、三方数据异步征信、策略流水异步入库
 */
@Slf4j
public class RiskExecutor {

    // 1. 定义全局共享的 TID 容器 (支持跨线程传递)
    public static final TransmittableThreadLocal<String> TRACE_ID = new TransmittableThreadLocal<>();

    // 2. 线程池实例 (采用延迟加载单例模式)
    private static volatile ExecutorService riskExecutor;

    // 3. 线程池核心参数 (根据 2026 业界金融风控标准)
    private static final int CPU_CORES = Runtime.getRuntime().availableProcessors();
    private static final int CORE_SIZE = CPU_CORES + 1; // 核心线程
    private static final int MAX_SIZE = CPU_CORES * 2;  // 最大线程
    private static final int QUEUE_CAPACITY = 500;      // 队列长度（防止堆积 OOM）

    /**
     * 获取风控核心线程池
     */
    public static ExecutorService getExecutor() {
        if (riskExecutor == null) {
            synchronized (RiskExecutor.class) {
                if (riskExecutor == null) {
                    // 使用 ThreadPoolExecutor 原生创建，确保参数透明
                    ThreadPoolExecutor executor = new ThreadPoolExecutor(
                            CORE_SIZE,
                            MAX_SIZE,
                            60L, TimeUnit.SECONDS,
                            new ArrayBlockingQueue<>(QUEUE_CAPACITY),
                            // 使用 Hutool 风格的工厂创建具名线程，方便排查 CPU 飙高
                            ThreadFactoryBuilder.create().setNamePrefix("risk-engine-").build(),
                            // 拒绝策略：金融场景建议由调用方运行（防止丢失请求），或记录错误日志抛出
                            new ThreadPoolExecutor.CallerRunsPolicy()
                    );

                    // 关键：包装为 TTL 线程池，实现 TraceID 自动透传
                    riskExecutor = TtlExecutors.getTtlExecutorService(executor);
                    log.info(">>> 风控核心线程池初始化成功 [核心: {}, 最大: {}, 队列: {}] <<<", CORE_SIZE, MAX_SIZE, QUEUE_CAPACITY);
                }
            }
        }
        return riskExecutor;
    }

    /**
     * 执行任务 (带日志追踪)
     */
    public static void execute(Runnable task) {
        getExecutor().execute(() -> {
            try {
                // 此时子线程已自动获取到父线程的 TRACE_ID
                task.run();
            } catch (Exception e) {
                log.error("[RiskExecutor] 任务执行异常, TID: {}", TRACE_ID.get(), e);
            }
        });
    }

    /**
     * 提交带返回值的任务
     */
    public static <T> Future<T> submit(Callable<T> task) {
        return getExecutor().submit(task);
    }

    /**
     * 监控方法：获取线程池实时状态
     * 建议配置在 Grafana 或 定时日志中
     */
    public static String getPoolStatus() {
        if (riskExecutor instanceof ThreadPoolExecutor) {
            ThreadPoolExecutor tpe = (ThreadPoolExecutor) riskExecutor;
            return String.format("PoolStatus: [Active: %d, Completed: %d, Queue: %d, PoolSize: %d]",
                    tpe.getActiveCount(), tpe.getCompletedTaskCount(), tpe.getQueue().size(), tpe.getPoolSize());
        }
        return "unknown";
    }
}

```

4. 业务使用示例
```
public void handleRiskCheck(String userId) {
    // 1. 模拟从 Header 获取 TID 并存入上下文
    String tid = "REQ_" + System.currentTimeMillis();
    RiskExecutor.TRACE_ID.set(tid);
    log.info("收到风控请求, 用户: {}, TID: {}", userId, tid);

    // 2. 异步调用多个风控子任务（例如：反欺诈库比对、黑名单校验）
    RiskExecutor.execute(() -> {
        // 这里会自动打印出父线程设置的 tid，无需手动传递参数
        log.info("开始查询黑名单..."); 
        // mock logic: checkBlacklist(userId);
    });

    RiskExecutor.execute(() -> {
        log.info("开始计算用户特征分...");
        // mock logic: calculateScore(userId);
    });

    // 3. 主线程继续返回结果给用户（低延迟响应）
}
```

```
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.UUID;
import java.util.concurrent.ExecutorService;

@Service
public class RiskAssessmentService {
    private static final Logger log = LoggerFactory.getLogger(RiskAssessmentService.class);

    @Resource
    @Qualifier("riskExecutor")
    private ExecutorService executor;

    public void processRisk(String userId) {
        // 1. 设置 TID (通常在拦截器拦截请求时统一设置)
        String tid = UUID.randomUUID().toString().replace("-", "");
        RiskThreadPoolConfig.TRACE_ID_HOLDER.set(tid);

        log.info("[主线程] 接收到风控请求, 用户: {}, TID: {}", userId, tid);

        // 2. 异步执行子任务
        executor.execute(() -> {
            // 这里不需要手动 get/set，TTL 已经自动同步了上下文
            String subTid = RiskThreadPoolConfig.TRACE_ID_HOLDER.get();
            log.info("[子线程] 正在进行反欺诈库核查, 当前 TID: {}", subTid);
            
            // 业务逻辑...
        });

        // 3. 主线程清除（防止 ThreadLocal 在线程池复用时产生内存泄漏或污染）
        // 注意：由于在 Controller/Interceptor 层通常有统一的 remove 操作，此处可根据架构决定是否手动 remove
        // RiskThreadPoolConfig.TRACE_ID_HOLDER.remove();
    }
}
```

优化点说明（相比 Hutool 版）
Spring 托管：通过 @Bean 定义，Spring Boot 在应用停止时会主动调用该线程池的 shutdown() 方法，保证正在运行的任务尽可能执行完，比全局静态变量更安全。
资源利用率：添加了 allowCoreThreadTimeOut(true)，这在金融业务波动较大的场景下（如夜间交易少时）能有效释放服务器内存资源。
零外部工具依赖：除了必须的 transmittable-thread-local（为了解决跨线程传递这一 JDK 本身的缺陷），完全使用 JDK 11 原生类，代码更轻量，且避开了 Hutool 版本更新可能带来的 API 变动。
性能优势：原生 ThreadPoolExecutor 的性能在 Java 11 下经过了充分优化，且 CallerRunsPolicy 拒绝策略在风控这种不能丢弃请求的场景中是最稳健的选择。

