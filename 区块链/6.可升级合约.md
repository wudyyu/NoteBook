### 可升级合约

> 在区块链开发中,合约一旦部署就无法更改其代码。然而,业务需求、安全漏洞修复和功能增强往往需要我们更新合约逻辑。可升级合约模式应运而生,允许我们在保留合约状态的同时更新合约逻辑。以下介绍三种主流的可升级合约模式,并以水龙头合约为例,来实践这三种模式。
> 在此之前,如果你没看过我的: Solidity 进阶教程,可以先看一下,后半部分有讲解代理合约与 UUPS 的实践

[合约升级](https://www.bilibili.com/video/BV12AxFewEXv/?spm_id_from=333.1387.homepage.video_card.click&vd_source=f6aabf9cca3c870729f9c09438330bbe)

> 透明代理

>> 透明代理是一种经典的可升级合约模式。它将存储数据和业务逻辑分离：
> >
> > 代理合约：负责保存数据（状态变量），对外暴露一个固定地址。
> >
> > 逻辑合约（实现合约）：只包含业务逻辑代码，不存储数据。
> >
> > 当用户调用代理合约时，代理会使用 delegatecall 把调用转发给逻辑合约。
> >
> > 因为 delegatecall 会在代理的存储上下文中执行逻辑合约的代码，所以数据保留在代理合约中。
> >
> > TokenFaucetV1 和 V2 与原 TokenFaucet 合约有几个关键区别，主要是为了支持可升级性：

- 主要区别:
> > 1. 继承关系变化
> > 原合约：直接继承 Ownable
> >
> > V1 合约：继承 Initializable 和 OwnableUpgradeable
> >
> > V2 合约：继承 V1 合约

>> 2. 构造函数 vs 初始化函数
> > 原合约：使用构造函数 constructor() 初始化状态
> >
> > V1 合约：
> >
> > 使用 initialize() 函数代替构造函数
> >
> > 添加了 initializer 修饰符确保只能初始化一次
> >
> > 添加了 _disableInitializers() 防止实现合约被直接初始化

- 存储间隙 (Storage Gap)

>> 存储间隙 (__gap) 是一种安全措施，确保在升级合约时不会破坏存储布局。它通过预留存储空间，使得父合约可以安全地添加新的状态变量，而不会影响子合约中状态变量的位置。这是可升级合约设计中的一个关键概念，确保数据在升级过程中的完整性

>> 在 Solidity 中，状态变量按照它们在合约中声明的顺序存储在区块链上。当我们升级合约时，如果在子合约中添加新的状态变量，这些新变量会被添加到存储布局的末尾

>> 但是，如果我们在父合约中添加新的状态变量，这会导致严重问题：
>>>> 1. 新的变量会插入到父合约和子合约的状态变量之间。
> > > >
> > > > 2. 这会导致子合约的所有状态变量位置发生偏移。
> > > >
> > > > 3. 结果是子合约的所有状态变量将指向错误的存储位置

>> 存储间隙的工作原理
> > uint256[50] private __gap;
>> 这行代码在父合约的末尾预留了 50 个存储槽。这些槽位不会被使用，但会占据存储空间。当父合约需要添加新的状态变量时，可以从这些预留的槽位中“借用”，而不是在末尾添加新的槽位
>> 这里的 50 是一个常用的默认值，提供了足够的空间来添加新的状态变量。如果预计父合约会添加很多新变量，可以增加这个数字

> 具体例子：假设我们有以下V1合约
```
// 定义父合约 ParentV1
contract ParentV1 {
    uint256 parentVar1;     // 父合约变量 1 (占用槽位 0)
    uint256 parentVar2;     // 父合约变量 2 (占用槽位 1)
    
    // 存储间隙：预留 50 个 uint256 类型的插槽 (占用槽位 2 到 51)
    // 目的是为了将来在 Parent 合约中添加新变量时，不影响子合约的存储位置
    uint256[50] private __gap; 
}

// 定义子合约 ChildV1，继承自 ParentV1
contract ChildV1 is ParentV1 {
    uint256 childVar1;      // 子合约变量 1 (从槽位 52 开始，紧跟在父合约间隙之后)
    uint256 childVar2;      // 子合约变量 2 (占用槽位 53)
}
```

>> 存储布局是：
> >
>> parentVar1 (槽位 0)
> >
> >  parentVar2 (槽位 1)
> >
> > __gap[0] 到 __gap[49] (槽位 2-51)
> >
>  > childVar1 (槽位 52)
> >
> > childVar2 (槽位 53)

> 现在，如果我们需要在父合约中添加一个新变量：
```
contract ParentV2 {
    uint256 parentVar1;
    uint256 parentVar2;
    uint256 newParentVar; // 新增变量
    uint256[49] private __gap; // 减少一个槽位
}

contract ChildV2 is ParentV2 {
    uint256 childVar1;
    uint256 childVar2;
}
```

>> 新的存储布局是：
> >
>> parentVar1 (槽位 0)
> >
> > parentVar2 (槽位 1)
> >
> > newParentVar (槽位 2) —— 从 __gap 中“借用”
> >
> > __gap[0] 到 __gap[48]（槽位 3-51）
> >
> > childVar1（槽位 52）- 位置不变！
> >
> > childVar2（槽位 53）- 位置不变！
> >
> > 关键是 childVar1 和 childVar2 的存储位置保持不变，因此代理合约中的数据仍然可以正确访问




































































































































