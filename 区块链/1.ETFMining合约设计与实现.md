# ETFMining 合约设计与实现

>> 本节将讲解 ETFMining 合约的设计与实现，这个合约是一个基于质押的挖矿奖励机制实现，主要用于激励用户持有并质押 ETF 代币。  
> > 用户通过将 ETF 代币质押到该合约中，可以按照时间和质押量比例获得挖矿奖励代币

>> 该合约的主要功能包括:
>>>> 1.允许用户质押 ETF 代币

>>>> 2.允许用户解除质押并取回 ETF 代币

>>>> 3.根据质押时间和数量计算并分发挖矿奖励

>>>> 4.允许管理员调整挖矿速度

> 指数奖励机制原理

>> 全局指数概念与时间线性增长模型

>>>> ETFMining 合约的核心是基于指数的奖励分配机制。全局指数 (miningLastIndex) 是一个随时间线性增长的累积值，其增长速度由每秒挖矿速度 (miningSpeedPerSecond) 决定

>>>> 全局指数的增长模型可以表示为：
```
新全局指数 = 旧全局指数 + (时间间隔 * 每秒挖矿速度 * INDEX_SCALE / 总质押量)
```
>>>> 这种模型确保了奖励的分配与时间成正比，与总质押量成反比，实现了按时间和质押量比例分配奖励的目标

> 指数精度与计算基数

>> 为了避免在区块链环境中处理小数时的精度问题,合约使用了一个高精度的计算基数 INDEX_SCALE = 1e36。这个基数足够大,可以在整数计算中保留足够的精度,避免了小数计算和舍入误差

>> 使用高精度基数的另一个好处是可以处理极小的挖矿速度和极大的质押量之间的比例关系,确保即使在极端情况下也能准确计算奖励

> 指数增量与奖励分配原理

>> 指数增量的概念

>> 指数增量 (deltaIndex) 是指全局指数在一段时间内的增长值。它的计算公式为：

```
指数增量 = 时间段内产生的奖励总量 * INDEX_SCALE / 总质押量
```

>> 用户奖励计算
>> 用户在两次指数更新之间应得的奖励计算公式为：
```
用户奖励 = 用户质押量 * (当前全局指数 - 用户上次更新时的指数) / INDEX_SCALE
```
>> 这种机制确保了用户获得的奖励与其质押量和质押时间成正比，实现了公平的奖励分配


- 案例分析
> 假设有以下初始状态：
>> 1.初始全局指数 miningLastIndex = 10^36 (即 1e36，合约初始化时设置)

>> 2.每秒挖矿速度 miningSpeedPerSecond = 10 (每秒产出10个代币)

>> 3.精度基数 INDEX_SCALE = 10^36 (即 1e36)

> 用户A在时间点1000开始质押
>> A质押了200个ETF代币

>> 总质押量=200(只有A质押)

>> 此时全局指数仍为初始值 10^36

>> A的用户指数 supplierLastIndex [A] 被设置为当前全局指数 1e36

> 用户B在时间点1300开始质押

>> 指数增量= 300 * 10 * (10^36) / 200 = 15 * (10^36) 【时间段300 * 每秒挖矿速度10 * INDEX_SCALE / 当前总质押量200】

>> 新的全局指数=(10^36) + 15*(10^36) = 16 * (10^36)  【旧的全局指数 + 指数增长】

>> B质押了800个ETF代币

>> 总质押量增加到 200+800=1000

>> B的用户指数 supplierLastIndex [B] 被设置为当前全局指数 16 * 10^36

> 时间点1600，全局指数再次更新
>> 从时间点1300到1600又过去了300秒

>> 这期间产生总奖励 = 10 * 300 个代币 = 3000 个代币

>> 总质押量 = 1000 (A和B共同质押)

>> 指数增量 = 300 * 10 * (10^36) / 1000 = 3 * (10^36)

>> 新的全局指数 = 16 * (10^36) + 3 * (10^36) = 19 * (10^36)

>  用户A在时间点1600查询或领取奖励
>> A的用户指数 supplierLastIndex [A] = (10^36) (初始质押时设置的)

>> 当前全局指数 = 19 * (10^36)

>> 指数差值 = 19 * (10^36) - (10^36) = 18 * (10^36)

>> A的奖励 = 200 * (18 * 10^36) / 10^36 = 3600 个代币

>> 这包括:
> > >> 时间段1000-1300: 200 * (15 *  (10^36) ) /  (10^36)  = 3000 个代币

>>>> 时间段1300-1600: 200 * (3 * (10^36)) / (10^36) = 600 个代币

> 用户B在时间点1600查询或领取奖励
>> B的用户指数 supplierLastIndex [B] = 16 * (10^36)  【在时间点1300质押时设置的】

>> 当前全局指数 =   19 * (10^36)

>> 指数差值 = 19 * (10^36) - 16 * (10^36) = 3 * (10^36)

>> B的奖励 = 800 * (3 * (10^36) )/ (10^36) = 800 * 3 = 2400个代币

>> 这只包括时间段1300-1600的奖励(80%的奖励),因为B是在时间点1300才开始质押的

> 奖励计算详解
>> 全局指数更新
>> 全局指数的更新是整个奖励机制的基础,它在以下情况下被触发:
>>>> 用户质押或解除质押时

>>>> 更新挖矿速度时

>>> 用户领取奖励时

>> 该算法的关键步骤是：
>>>> 1.计算自上次更新以来的时间间隔 (deltaTime)

> > > >  2.计算这段时间内应产生的总奖励 (deltaReward = miningSpeedPerSecond * deltaTime)

>>>> 3.将总奖励转换为指数增量 (deltaIndex = deltaReward * INDEX_SCALE / totalStaked)

>>>> 4.将指数增量添加到全局指数中 (miningLastIndex += deltaIndex)

>>>> 5.更新最后更新时间戳 (lastIndexUpdateTime = block.timestamp)

-  这个指数增量表示每单位质押在这段时间内应获得的奖励指数。全局指数会随着时间的推移不断累加这些增量

>> 为什么需要指数机制?
>> 指数机制解决了几个关键问题：

>> 1.按比例公平分配奖励:
> > >> 通过将奖励转换为指数增量，每个用户可以根据自己的质押比例获得相应的奖励

>>>> 无论用户质押多少，都能按比例获得公平的奖励




























