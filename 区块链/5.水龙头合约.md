# TokenFaucet实现
> TokenFaucet 合约的主要目的是为测试用户提供测试代币, 使他们能够在不使用真实资产的情况下测试 LeapETF 项目的功能。  
> 这种水龙头 (Faucet) 机制在区块链开发中非常常见, 它允许开发者和用户在测试环境中获取必要的代币资源

>> 该合约的主要功能包括:
> > 1.分发多种测试代币 (WBTC、WETH、LINK、USDC)

>> 2.限制用户请求频率, 防止滥用

>> 3.允许管理员调整分发数量和冷却期

>> 4.提供查询接口, 方便用户了解可获取的代币数量和冷却状态

- 代币分发机制

> 分发数量
> 合约为每种代币设置了不同的分发数量, 这些数量考虑了代币的实际价值和小数位数

```
uint256 public lbtcAmount = 0.1 * 10**8; // 0.1 WBTC (8 decimals)
uint256 public lethAmount = 0.5 * 10**18; // 0.5 WETH (18 decimals)
uint256 public linkAmount = 50 * 10**18; // 50 LINK (18 decimals)
uint256 public usdcAmount = 500 * 10**6; // 500 USDC (6 decimals)
```

> 这里需要注意的是, 不同代币有不同的小数位数:

>> WBTC 使用 8 位小数

>> WETH 和 LINK 使用 18 位小数

>> USDC 使用 6 位小数

### 冷却期

> 为了防止用户滥用水龙头资源,合约实现了冷却期机制:

```
// Cooldown period for each address (2 hours)
uint256 public cooldownPeriod = 2 hours;

// Mapping to track last request time for each address
mapping(address => mapping (address => uint256)) public lastRequestTime;
```

> 冷却期机制的工作原理是:
>> 1.每次用户请求代币时,记录当前时间戳

>> 2.用户再次请求同一代币时,检查是否已经过了冷却期

>> 3.只有在冷却期过后,用户才能再次请求同一代币

> 用户请求追踪

> > 合约使用嵌套映射来追踪用户的请求历史:
```
mapping(address => mapping (address => uint256)) public lastRequestTime;
```

>> 1.外层映射的键是用户地址

>> 2.内层映射的键是代币地址

>> 3.值是上次请求的时间戳

### 核心功能

#### 单一代币请求功能

> requestTokens 函数允许用户请求单一类型的代币

>> 该函数的执行流程如下:

>> 1.验证请求的代币是否受支持

>> 2.检查用户是否已经过了冷却期

>> 3.根据代币类型确定分发数量

>> 4.检查合约是否有足够的代币余额

>> 5.更新用户的最后请求时间

>> 6.将代币转移给用户

>> 7.触发代币分发事件

```
function requestTokens (address tokenAddress) external {
    require(
        tokenAddress == address(mockWBTC) ||
        tokenAddress == address(mockWETH) ||
        tokenAddress == address(mockLINK) ||
        tokenAddress == address(mockUSDC),
        "TokenFaucet: Unsupported token"
    );
    require(
        block.timestamp >= lastRequestTime[msg.sender][tokenAddress] + cooldownPeriod,
        "TokenFaucet: Cooldown period not elapsed"
    );
    uint256 amount;
    IERC20 token = IERC20(tokenAddress);
    if (tokenAddress == address(mockWBTC)) {
        amount = wbtcAmount;
    } else if (tokenAddress == address(mockWETH)) {
        amount = wethAmount;
    } else if (tokenAddress == address(mockLINK)) {
        amount = linkAmount;
    } else if (tokenAddress == address(mockUSDC)) {
        amount = usdcAmount;
    }
    require(
        token.balanceOf(address(this)) >= amount,
        "Token Faucet: Insufficient token balance"
    );
    
    // Update last request time
    lastRequestTime[msg.sender][tokenAddress] = block.timestamp;

    // Transfer tokens to the requester
    require(token.transfer(msg.sender, amount), "TokenFaucet: Transfer failed");

    emit TokensDispensed(msg.sender, tokenAddress, amount);
}
```

#### 批量代币请求功能

> requestAllTokens 函数允许用户一次性请求所有支持的代币:

>> 这个函数的执行流程如下:

>> 1.创建一个包含所有支持代币地址的数组

>> 2.遍历数组,对每种代币执行以下操作:
>>>> 检查冷却期,如果未过期则跳过

>>>> 确定分发数量

>>>> 检查余额,如果不足则跳过

>>>> 更新最后请求时间

>>>> 转移代币给用户

>>>> 触发事件

> 与单一代币请求不同,批量请求在遇到问题时不会回滚整个交易,而是简单地跳过有问题的代币,继续处理其他代币。  
> 这种设计提高了用户体验,即使某些代币不可用,用户仍然可以获取其他可用的代币

```
function requestAllTokens() external {
    address [] memory tokens = new address [] (4);
    tokens [0] = address (mockWBTC);
    tokens [1] = address (mockWETH);
    tokens [2] = address (mockLINK);
    tokens [3] = address (mockUSDC);
    for (uint i=0; i < tokens.length; i++) {
        address tokenAddress = tokens [i];
        // Skip if cooldown period not elapsed
        if (block.timestamp < lastRequestTime [msg.sender] [tokenAddress] + cooldownPeriod)
        continue;
    }
    uint256 amount;
    IERC20 token = IERC20 (tokenAddress);
    if (tokenAddress == address (mockWBTC)) {
        amount = wbtcAmount;
    } else if (tokenAddress == address (mockWETH)) {
        amount = wethAmount;
    } else if (tokenAddress == address (mockLINK)) {
        amount = linkAmount;
    } else if (tokenAddress == address (mockUSDC)) {
        amount = usdcAmount;
    }
    // Skip if insufficient balance
    if (token.balanceOf(address(this)) < amount) {
        continue;
    }
    
    // Update last request time
    lastRequestTime[msg.sender][tokenAddress] = block.timestamp;

    // Transfer tokens to the requester
    if (token.transfer(msg.sender, amount)) {
       emit TokensDispensed(msg.sender, tokenAddress, amount);
   }
}
```

#### 参数配置功能
> 合约提供了两个管理员函数来调整关键参数:

```
function updateTokenAmount (address tokenAddress, uint256 newAmount) external onlyOwner {
    require(
        tokenAddress == address (mockWBTC) ||
        tokenAddress == address (mockWETH) ||
        tokenAddress == address (mockLINK) ||
        tokenAddress == address (mockUSDC),
        "TokenFaucet: Unsupported token"
    );

    if (tokenAddress == address (mockWBTC)) {
        wbtcAmount = newAmount;
    } else if (tokenAddress == address (mockWETH)) {
        wethAmount = newAmount;
    } else if (tokenAddress == address (mockLINK)) {
        linkAmount = newAmount;
    } else if (tokenAddress == address (mockUSDC)) {
        usdcAmount = newAmount;
    }

    emit AmountUpdated (tokenAddress, newAmount);
}

function updateCooldownPeriod (uint256 newCooldown) external onlyOwner {
    cooldownPeriod = newCooldown;
    emit CooldownUpdated (newCooldown);
}
```

> 这两个函数分别用于:
>> 1.更新特定代币的分发数量

>> 2.更新全局冷却期

这些函数都使用了 onlyOwner 修饰符, 确保只有合约所有者才能调用它们, 这是一种常见的权限控制模式。  
每个函数都会触发相应的事件, 以便前端应用程序和其他监听者可以获知参数变更


















































